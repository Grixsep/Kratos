// KRATOS ___                _   _ _         _   _             __                       _
//       / __\___  _ __  ___| |_(_) |_ _   _| |_(_)_   _____  / /  __ ___      _____   /_\  _ __  _ __
//      / /  / _ \| '_ \/ __| __| | __| | | | __| \ \ / / _ \/ /  / _` \ \ /\ / / __| //_\\| '_ \| '_  |
//     / /__| (_) | | | \__ \ |_| | |_| |_| | |_| |\ V /  __/ /__| (_| |\ V  V /\__ \/  _  \ |_) | |_) |
//     \____/\___/|_| |_|___/\__|_|\__|\__,_|\__|_| \_/ \___\____/\__,_| \_/\_/ |___/\_/ \_/ .__/| .__/
//                                                                                         |_|   |_|
//
//  License:		 BSD License
//					 license: structural_mechanics_application/license.txt
//
//  Author:    athira vadakkekkara
// note : tangent modulus: both analytical and numerical, dEpsprdEps- all three methods, M- new one


// Project includes
#include "elastic_local_anisotropic_damage_3d.h"
#include "constitutive_laws_application_variables.h"
#include "custom_utilities/tangent_operator_calculator_utility.h"
#include "structural_mechanics_application_variables.h"
#include "custom_utilities/advanced_constitutive_law_utilities.h"
#include "custom_utilities/constitutive_law_utilities.h"
#include "includes/checks.h"
#include "utilities/math_utils.h"

namespace Kratos
{
//******************************CONSTRUCTOR*******************************************
//************************************************************************************

ElasticAnisotropicDamage::ElasticAnisotropicDamage()
    : ElasticIsotropic3D()
{
}

//********************************COPY CONSTRUCTOR************************************
//************************************************************************************

ElasticAnisotropicDamage::ElasticAnisotropicDamage(const ElasticAnisotropicDamage &rOther)
    : ElasticIsotropic3D(rOther)
{
}

//********************************CLONE***********************************************
//************************************************************************************

ConstitutiveLaw::Pointer ElasticAnisotropicDamage::Clone() const
{
    return Kratos::make_shared<ElasticAnisotropicDamage>(ElasticAnisotropicDamage(*this));
}

//********************************DESTRUCTOR******************************************
//************************************************************************************

ElasticAnisotropicDamage::~ElasticAnisotropicDamage()
{
}

//********************************DESTRUCTOR******************************************
//************************************************************************************

int ElasticAnisotropicDamage::Check(
    const Properties& rMaterialProperties,
    const GeometryType& rElementGeometry,
    const ProcessInfo& rCurrentProcessInfo
    ) const
{
    KRATOS_CHECK(rMaterialProperties.Has(YOUNG_MODULUS));
    KRATOS_CHECK(rMaterialProperties.Has(POISSON_RATIO));
    KRATOS_CHECK(rMaterialProperties.Has(YIELD_STRESS_TENSION));
    KRATOS_CHECK(rMaterialProperties.Has(YIELD_STRESS_COMPRESSION));
    KRATOS_CHECK(rMaterialProperties.Has(DAMAGE_MODEL_PARAMETER_BETA1_TENSION));
    KRATOS_CHECK(rMaterialProperties.Has(DAMAGE_MODEL_PARAMETER_BETA2_TENSION));
    KRATOS_CHECK(rMaterialProperties.Has(DAMAGE_MODEL_PARAMETER_BETA1_COMPRESSION));
    KRATOS_CHECK(rMaterialProperties.Has(DAMAGE_MODEL_PARAMETER_BETA2_COMPRESSION));
    return 0;
}

//************************************************************************************
//************************************************************************************

bool ElasticAnisotropicDamage::Has(const Variable<double>& rThisVariable)
{
    if(rThisVariable == STRAIN_ENERGY){
        // explicitly returning "false", so the element calls CalculateValue(...)
        return false;
    } else if(rThisVariable == DAMAGE_VARIABLE){
        return false;
    }

    return false;
}

//************************************************************************************
//************************************************************************************

bool ElasticAnisotropicDamage::Has(const Variable<Vector>& rThisVariable)
{
    if(rThisVariable == INTERNAL_VARIABLES){
        // explicitly returning "false", so the element calls CalculateValue(...)s
        return true;
    } else if(rThisVariable == STRAIN){
        // explicitly returning "false", so the element calls CalculateValue(...)
        return false;
    } else if(rThisVariable == DAMAGE_VECTOR){
        return true;
    }

    return false;
}
//************************************************************************************
//************************************************************************************

Vector& ElasticAnisotropicDamage::GetValue(
    const Variable<Vector>& rThisVariable,
    Vector& rValues
    )
{
    KRATOS_TRY
    if(rThisVariable == DAMAGE_VECTOR){
        rValues = mDamageVector;
    }else if(rThisVariable == INTERNAL_VARIABLES){
        rValues = mStrainVariables;
    }
    return rValues;
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::SetValue(
    const Variable<Vector>& rThisVariable,
    const Vector& rValues,
    const ProcessInfo& rProcessInfo
    )
{
    KRATOS_TRY
    if(rThisVariable == DAMAGE_VECTOR){
        mDamageVector = rValues;
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::InitializeMaterial(
    const Properties& rMaterialProperties,
    const GeometryType& rElementGeometry,
    const Vector& rShapeFunctionsValues
    )
{
    // const double yield_stress = rMaterialProperties[STRESS_LIMITS](0);
    // const double young_modulus = rMaterialProperties[YOUNG_MODULUS];
    // mStrainVariables = yield_stress / std::sqrt(young_modulus);
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::FinalizeMaterialResponseCauchy(
    ConstitutiveLaw::Parameters& rParametersValues)
{
    KRATOS_TRY
    Vector damage_vector;
    Vector strain_variables;
    this->CalculateStressResponse(rParametersValues, damage_vector, strain_variables);
    mDamageVector = damage_vector;
    mStrainVariables = strain_variables;

    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::CalculateMaterialResponsePK2(
    ConstitutiveLaw::Parameters& rParametersValues)
{
    KRATOS_TRY
    Vector damage_vector;
    Vector strain_variables;
    CalculateStressResponse(rParametersValues, damage_vector, strain_variables);

    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::CalculateStressResponse(
    ConstitutiveLaw::Parameters& rParametersValues,
    Vector& rDamageVector,
    Vector& rStrainVariables)
{
    KRATOS_TRY
    const Properties& r_material_properties = rParametersValues.GetMaterialProperties();
    Flags& r_constitutive_law_options = rParametersValues.GetOptions();
    Vector& r_strain_vector = rParametersValues.GetStrainVector();
    //KRATOS_WATCH(r_strain_vector)
    CalculateValue(rParametersValues, STRAIN, r_strain_vector);
    rStrainVariables = mStrainVariables;
    // If we compute the tangent moduli or the stress
    if( r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_STRESS ) ||
        r_constitutive_law_options.Is( ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR ))
        {
        Vector& r_stress_vector       = rParametersValues.GetStressVector();
        const Vector& r_strain_vector = rParametersValues.GetStrainVector();
        KRATOS_WATCH(r_strain_vector)
        Matrix& r_constitutive_matrix = rParametersValues.GetConstitutiveMatrix();
        CalculateElasticMatrix(r_constitutive_matrix, rParametersValues);
        noalias(r_stress_vector)      = prod(r_constitutive_matrix, r_strain_vector);
        const double beta1t = r_material_properties[DAMAGE_MODEL_PARAMETER_BETA1_TENSION];
        const double beta2t = r_material_properties[DAMAGE_MODEL_PARAMETER_BETA2_TENSION];
        const double beta1c = r_material_properties[DAMAGE_MODEL_PARAMETER_BETA1_COMPRESSION];
        const double beta2c = r_material_properties[DAMAGE_MODEL_PARAMETER_BETA2_COMPRESSION];
        const double E   = r_material_properties[YOUNG_MODULUS];
        const double fck = r_material_properties[YIELD_STRESS_COMPRESSION];
        const double ft  = r_material_properties[YIELD_STRESS_TENSION];
        Vector damage_vector= ZeroVector(3);
        BoundedVectorType Spr = ZeroVector(3);
        BoundedVectorType k0 = ZeroVector(3);
        BoundedVectorType beta1 = ZeroVector(3);
        BoundedVectorType beta2 = ZeroVector(3);
        BoundedVectorType kappa = ZeroVector(3);
        BoundedVectorType F     = ZeroVector(3);
        BoundedMatrixVoigtType EffStiffnessMatrix = ZeroMatrix(6, 6);
        BoundedMatrix3x6Type dEprdE = ZeroMatrix(3,6);
        BoundedMatrixType dkdEpr = ZeroMatrix(3,3);
        array_1d<BoundedMatrix<double, 6, 6>, 3> dHdk;
        for (SizeType i = 0; i < Dimension; ++i){
            dHdk[i] = ZeroMatrix(6,6);
        }
        Vector max_history_e = ZeroVector(3);

        double k0t, k0c;
        if(r_material_properties.Has(DAMAGE_THRESHOLD_TENSION)==true){
            k0t = r_material_properties[DAMAGE_THRESHOLD_TENSION];
        }else{
            k0t = ft/E;
        }
        if(r_material_properties.Has(DAMAGE_THRESHOLD_COMPRESSION)==true){
            k0c = r_material_properties[DAMAGE_THRESHOLD_COMPRESSION];
        }else{
            k0c = (10./3.) * ft/E;
        }
        BoundedVectorType principal_strains = ZeroVector(3);
        GetEigenValues(principal_strains, STRAIN, r_strain_vector);  //calculate prinicpal strains
        for(SizeType i = 0; i < Dimension; ++i) {
            k0[i] = (principal_strains[i] > eps) ? k0t : k0c;
            beta1[i] = (principal_strains[i] > eps) ? beta1t : beta1c;
            beta2[i] = (principal_strains[i] > eps) ? beta2t : beta2c;
            max_history_e[i] = std::max(mStrainVariables[i], fabs(principal_strains[i]));
            kappa[i]       = std::max(max_history_e[i], k0[i]);
            F[i]           = fabs(principal_strains[i])-kappa[i];
        }
        //Compute damage in principal directions
        for (SizeType i = 0; i < Dimension; ++i) {
            if (kappa[i]>= 0 && kappa[i]<=k0[i]) {
                damage_vector[i]=0.0;
            }else if (kappa[i]> k0[i]){
                const double var1      = pow((k0[i]/kappa[i]),beta1[i]);
                const double var2      = exp(-beta2[i]*((kappa[i]-k0[i])/(k0[i])));
                damage_vector[i] = 1.0 - var1 * var2;
            }
            if(damage_vector[i] < 0.0){
                damage_vector[i] = 0.0;
            }
        }
        KRATOS_WATCH(damage_vector)
        if(damage_vector[0] > 0.0 || damage_vector[1] > 0.0 || damage_vector[2] > 0.0){
            CalculateParameters(EffStiffnessMatrix, dEprdE, dkdEpr, rParametersValues, damage_vector);
            KRATOS_WATCH(EffStiffnessMatrix)
            noalias(r_stress_vector) = prod(EffStiffnessMatrix,r_strain_vector);
            //if (r_constitutive_law_options.Is(ConstitutiveLaw::COMPUTE_CONSTITUTIVE_TENSOR)) {
                // this->CalculateTangentTensor(rParametersValues);
            //}
            CalculatePartialDerivatives(dHdk, r_material_properties, damage_vector, k0, beta1, beta2, kappa);
            const BoundedMatrix3x6Type dkdE = prod(dkdEpr, dEprdE);
            array_1d<BoundedMatrix<double, 6, 6>, 6> dHdE;
            for (SizeType i = 0; i < VoigtSize; ++i){
            dHdE[i] = ZeroMatrix(6,6);
            }
            GetdHdE(dHdE, dHdk, dkdE);
            BoundedMatrixVoigtType dSdE = ZeroMatrix(6,6);
            MultiplyTensors(dSdE, dHdE, r_strain_vector);
            noalias(r_constitutive_matrix) = EffStiffnessMatrix + dSdE;
            KRATOS_WATCH(r_constitutive_matrix)

        }
        rDamageVector = damage_vector;
        rStrainVariables = max_history_e;
        KRATOS_WATCH(r_stress_vector)
        KRATOS_WATCH(rParametersValues.GetProcessInfo()[TIME]);
        KRATOS_WATCH("-------------------------------------------");
        }
    KRATOS_CATCH("")
}


//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::TensorProduct6(
    Matrix& rOutput,
    const Vector& rVector1,
    const Vector& rVector2)
{
    KRATOS_TRY
    KRATOS_DEBUG_ERROR_IF(rVector1.size()!=6 || rVector2.size()!=6) << "check the size of vectors  ";

    if (rOutput.size1() != 6 || rOutput.size1() != 6) {
        rOutput.resize(6, 6,false);
    }
    for(int i=0; i<6; ++i){
        for(int j=0; j<6; ++j){
            rOutput(i,j)= rVector1[i] * rVector2[j];
        }
    }

    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::GetEigenValues(
    BoundedVectorType& Pri_Values,
    const Variable<Vector>& rThisVariable,
    const Vector& VectorForm)
{
    KRATOS_TRY
    BoundedMatrixType MatrixForm = ZeroMatrix(3,3);
    BoundedMatrixType EigenVectors;
    BoundedMatrixType EigenValues = ZeroMatrix(3,3);
    VectorToTensor(MatrixForm, VectorForm, rThisVariable);
    MathUtils<double>::GaussSeidelEigenSystem(MatrixForm, EigenVectors, EigenValues);
    Pri_Values[0] = EigenValues(0,0);
    Pri_Values[1] = EigenValues(1,1);
    Pri_Values[2] = EigenValues(2,2);
    KRATOS_CATCH("")
}
/***********************************************************************************/
/***********************************************************************************/
void ElasticAnisotropicDamage::CalculateTangentTensor(ConstitutiveLaw::Parameters& rValues)
{
    KRATOS_TRY
    const Properties& r_material_properties = rValues.GetMaterialProperties();

    const bool consider_perturbation_threshold = r_material_properties.Has(CONSIDER_PERTURBATION_THRESHOLD) ? r_material_properties[CONSIDER_PERTURBATION_THRESHOLD] : true;
    const TangentOperatorEstimation tangent_operator_estimation = r_material_properties.Has(TANGENT_OPERATOR_ESTIMATION) ? static_cast<TangentOperatorEstimation>(r_material_properties[TANGENT_OPERATOR_ESTIMATION]) : TangentOperatorEstimation::SecondOrderPerturbation;

    if (tangent_operator_estimation == TangentOperatorEstimation::Analytic) {
        KRATOS_ERROR << "Analytic solution not available" << std::endl;
    } else if (tangent_operator_estimation == TangentOperatorEstimation::FirstOrderPerturbation) {
        // Calculates the Tangent Constitutive Tensor by perturbation (first order)
        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 1);
    } else if (tangent_operator_estimation == TangentOperatorEstimation::SecondOrderPerturbation) {
        // Calculates the Tangent Constitutive Tensor by perturbation (second order)
        TangentOperatorCalculatorUtility::CalculateTangentTensor(rValues, this, ConstitutiveLaw::StressMeasure_Cauchy, consider_perturbation_threshold, 2);
    }
    KRATOS_CATCH("")
}
//************************************************************************************
//************************************************************************************

Vector& ElasticAnisotropicDamage::CalculateValue(
    ConstitutiveLaw::Parameters& rParametersValues,
    const Variable<Vector>& rThisVariable,
    Vector& rValues
    )
{
    KRATOS_TRY
    if (rThisVariable == DAMAGE_VECTOR) {
        Vector damage_vector;
        Vector strain_variables;
        this->CalculateStressResponse( rParametersValues, damage_vector, strain_variables);
        rValues = damage_vector;
    }else if(rThisVariable == INTERNAL_VARIABLES){
        Vector damage_vector;
        Vector strain_variables;
        this->CalculateStressResponse( rParametersValues, damage_vector, strain_variables);
        rValues = strain_variables;
    }else{
        ElasticIsotropic3D::CalculateValue(rParametersValues, rThisVariable, rValues);
    }
    return( rValues );
    KRATOS_CATCH("")
}

//************************************************************************************
//***********************************************************************************

void ElasticAnisotropicDamage::GetDamageEffectTensor(
    BoundedMatrixVoigtType& DamageEffectTensor,
    const BoundedVectorType& DamageVector

)
{
    KRATOS_TRY
    const double D1 =  DamageVector[0];
    const double D2 =  DamageVector[1];
    const double D3 =  DamageVector[2];
    DamageEffectTensor(0,0) = pow((1-D1),(-1));
    DamageEffectTensor(1,1) = pow((1-D2),(-1));
    DamageEffectTensor(2,2) = pow((1-D3),(-1));
    DamageEffectTensor(3,3) = pow((1-((D1+D2)*0.5)),(-1));
    DamageEffectTensor(4,4) = pow((1-((D2+D3)*0.5)),(-1));
    DamageEffectTensor(5,5) = pow((1-((D1+D3)*0.5)),(-1));

    KRATOS_CATCH("")
}
//************************************************************************************
//***********************************************************************************

void ElasticAnisotropicDamage::CalculateParameters(
    BoundedMatrixVoigtType& EffStiffnessMatrix,
    BoundedMatrix3x6Type& dEprdE,
    BoundedMatrixType& dkdEpr,
    ConstitutiveLaw::Parameters& rParametersValues,
    const Vector& DamageVector
)
{
    KRATOS_TRY
    Matrix& r_constitutive_matrix = rParametersValues.GetConstitutiveMatrix();
    const Vector& r_strain_vector = rParametersValues.GetStrainVector();
    BoundedMatrixVoigtType M     = ZeroMatrix(6,6);
    BoundedMatrixVoigtType Inv_M = ZeroMatrix(6,6);
    BoundedVectorType principal_strains = ZeroVector(3);
    CalculateElasticMatrix(r_constitutive_matrix, rParametersValues);
    Inv_M(0,0) = 1 -DamageVector[0];
    Inv_M(1,1) = 1 -DamageVector[1];
    Inv_M(2,2) = 1 -DamageVector[2];
    Inv_M(3,3) = sqrt ((1-DamageVector[0])*(1-DamageVector[1]));
    Inv_M(4,4) = sqrt ((1-DamageVector[1])*(1-DamageVector[2]));
    Inv_M(5,5) = sqrt ((1-DamageVector[0])*(1-DamageVector[2]));
    const BoundedMatrixVoigtType a = prod(r_constitutive_matrix,trans(Inv_M));
    EffStiffnessMatrix = prod(Inv_M,a);
    GetEigenValues(principal_strains, STRAIN, r_strain_vector);
    CalculateDerivativesofEigenvalues(dEprdE, principal_strains, r_strain_vector, STRAIN);
    for(SizeType i = 0; i < Dimension; ++i){
        if(DamageVector[i] > 0){
            if(principal_strains[i]<0){
                dkdEpr(i,i) = -1;
            }else{
                dkdEpr(i,i) = 1;
            }
        }
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::CalculatePartialDerivatives(
    array_1d<BoundedMatrix<double, 6, 6>, 3>& dHdk,
    const Properties& rMaterialProperties,
    const Vector& DamageVector,
    const BoundedVectorType& Kappa0,
    const BoundedVectorType& Beta1,
    const BoundedVectorType& Beta2,
    const BoundedVectorType& Kappa
)
{
    KRATOS_TRY
    const double E   = rMaterialProperties[YOUNG_MODULUS];
    const double nu  = rMaterialProperties[POISSON_RATIO];
    const double E_factor =  E/((1 + nu ) * (1- 2 * nu));
    BoundedMatrixType dDdkappa = ZeroMatrix(3,3);
    array_1d<BoundedMatrix<double, 6, 6>, 3> dHdD;
    for (SizeType i = 0; i < Dimension; ++i){
        dHdD[i] = ZeroMatrix(6,6);
    }
    for(SizeType i =0; i < Dimension; ++i){
        dDdkappa(i,i)   =  (1- DamageVector[i]) * (Beta1[i]/Kappa[i] + Beta2[i]/Kappa0[i]);
    }
    for(SizeType i =0; i < Dimension; ++i){
        for(SizeType j = 0; j < Dimension; ++j){
            for(SizeType k = 0; k < Dimension; ++k){
                dHdD[i](i,i) = E_factor * (-2 * (1-DamageVector[i]) * (1-nu));
                if(j != k && (i==j ||i ==k)){
                    SizeType m = (i==j) ? k : j;
                    dHdD[i](j,k) = -E_factor * nu * (1 - DamageVector[m]);
                }
            }
        }
    }
    dHdD[0](3,3) = E_factor * 0.5 * (1-2*nu) * (DamageVector[1]-1) ;
    dHdD[0](5,5) = E_factor * 0.5 * (1-2*nu) * (DamageVector[2]-1) ;
    dHdD[1](3,3) = E_factor * 0.5 * (1-2*nu) * (DamageVector[0]-1) ;
    dHdD[1](4,4) = E_factor * 0.5 * (1-2*nu) * (DamageVector[2]-1) ;
    dHdD[2](4,4) = E_factor * 0.5 * (1-2*nu) * (DamageVector[1]-1) ;
    dHdD[2](5,5) = E_factor * 0.5 * (1-2*nu) * (DamageVector[0]-1) ;
    GetdHdk(dHdk, dHdD, dDdkappa);

    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::VectorToTensor(
    BoundedMatrixType& TensorForm,
    const Vector& VectorForm,
    const Variable<Vector>& rThisVariable
)
{
    KRATOS_TRY
    if(rThisVariable == STRESSES){
        TensorForm(0,1)= TensorForm(1,0)= VectorForm[3];
        TensorForm(0,2)= TensorForm(2,0)= VectorForm[5];
        TensorForm(2,1)= TensorForm(1,2)= VectorForm[4];
    }else if(rThisVariable == STRAIN){
        TensorForm(0,1)= TensorForm(1,0)= 0.5 * VectorForm[3];
        TensorForm(0,2)= TensorForm(2,0)= 0.5 * VectorForm[5];
        TensorForm(2,1)= TensorForm(1,2)= 0.5 * VectorForm[4];
    }
    for(SizeType i = 0; i < Dimension; ++i){
        TensorForm(i,i) = VectorForm[i];
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::CalculateDerivativesofEigenvalues(
     BoundedMatrix3x6Type &DerivativesofEigenvalues,
     BoundedVectorType &EigenvaluesVector,
     const BoundedVectorVoigtType &Voigtform,
     const Variable<Vector>& rThisVariable
    )
{
    KRATOS_TRY
    BoundedMatrixType Matrixform;
    VectorToTensor(Matrixform, Voigtform, rThisVariable);
    BoundedMatrixType EigenVectors;
    BoundedMatrixType EigenValues = ZeroMatrix(3,3);
    MathUtils<double>::GaussSeidelEigenSystem(Matrixform, EigenVectors, EigenValues);
    BoundedVectorType Eigen_vector_column = ZeroVector (3) ;
    BoundedMatrixType DerivativesMatrix = ZeroMatrix(3,3);
    for(SizeType i = 0; i < Dimension; ++i){
        Eigen_vector_column = column(EigenVectors,i);
        DerivativesMatrix = outer_prod(Eigen_vector_column, Eigen_vector_column);
        DerivativesofEigenvalues(i,0) = DerivativesMatrix(0,0);
        DerivativesofEigenvalues(i,1) = DerivativesMatrix(1,1);
        DerivativesofEigenvalues(i,2) = DerivativesMatrix(2,2);
        DerivativesofEigenvalues(i,3) = DerivativesMatrix(0,1);
        DerivativesofEigenvalues(i,4) = DerivativesMatrix(1,2);
        DerivativesofEigenvalues(i,5) = DerivativesMatrix(2,0);
    }

    // if( (fabs(EigenvaluesVector(0)-EigenvaluesVector(1)) < 2.0*eps ) && ( fabs(EigenvaluesVector(0)-EigenvaluesVector(2)) < 2.0*eps ) && ( fabs(EigenvaluesVector(1)-EigenvaluesVector(2)) < 2.0*eps ) ){
    //     EigenvaluesVector(0) = EigenvaluesVector(0) + 1.1*eps;
    //     EigenvaluesVector(1) = EigenvaluesVector(1) + 0.75*eps;
    //     EigenvaluesVector(2) = EigenvaluesVector(2) + 0.5*eps;
    //     DerivativesofEigenvalues(0,0) = 1.0;
    //     DerivativesofEigenvalues(1,1) = 1.0;
    //     DerivativesofEigenvalues(2,2) = 1.0;
    // }else{
    //     if( fabs(EigenvaluesVector(0)-EigenvaluesVector(1)) < eps ) EigenvaluesVector(1) = EigenvaluesVector(1) - eps;
    //     if( fabs(EigenvaluesVector(1)-EigenvaluesVector(2)) < eps ) EigenvaluesVector(2) = EigenvaluesVector(2) - eps;

    // }
    // Matrix indx = ZeroMatrix(3, 3);
    // Vector Vectorform_squared(6);
    // Vector dSprdS_entries(6);
    // Vector dI1dS = ZeroVector(6);
    // dI1dS[0] = dI1dS[1] = dI1dS[2]= 1.0;

    // indx(0,1)= indx(1,0)= indx(2,2)=1.0;
    // indx(0,2)= indx(1,1)= indx(2,0)=2.0;
    // Matrix Matrixform_squared = ZeroMatrix(3,3);
    // Matrixform_squared = prod(Matrixform, Matrixform);
    // Vectorform_squared[0]= Matrixform_squared(0,0);
    // Vectorform_squared[1]= Matrixform_squared(1,1);
    // Vectorform_squared[2]= Matrixform_squared(2,2);
    // Vectorform_squared[3]= Matrixform_squared(1,2);
    // Vectorform_squared[4]= Matrixform_squared(0,2);
    // Vectorform_squared[5]= Matrixform_squared(0,1);

    // for(int i=0; i<3; ++i){
    //     dSprdS_entries  = Vectorform_squared - ( EigenvaluesVector(indx(1,i)) + EigenvaluesVector(indx(2,i)) )*(Voigtform) + EigenvaluesVector(indx(1,i)) * EigenvaluesVector(indx(2,i)) * dI1dS;
    //     dSprdS_entries /=  (EigenvaluesVector(indx(0,i)) - EigenvaluesVector(indx(1,i)) ) * ( EigenvaluesVector(indx(0,i)) - EigenvaluesVector(indx(2,i)) );
    //     for(int j=0; j<6; ++j){
    //         DerivativesofEigenvalues(i,j)= dSprdS_entries[j];
    //     }
    //     for(int k=3; k<6; ++k){
    //         DerivativesofEigenvalues(i,k) *= 2.;
    //     }
    // }
    // BoundedMatrixType DerivtivesMatrix;
    // for(SizeType i = 0; i < Dimension; ++i){
    //     for(SizeType j = 0; j < Dimension; ++j){
    //         if(i != j && Matrixform(i,j)< eps){
    //             Matrixform(i,j) = eps;
    //         }
    //     }
    // }
    // for(SizeType i = 0; i < Dimension; ++i){
    //     BoundedMatrixType AminusLambdaMatrix = Matrixform - EigenvaluesVector[i] * IdentityMatrix(Dimension, Dimension);
    //     BoundedMatrixType cofactor_matrix = MathUtils<double>::CofactorMatrix(AminusLambdaMatrix);
    //     const double trace = cofactor_matrix(0,0) + cofactor_matrix(1,1) + cofactor_matrix(2,2);
    //     DerivtivesMatrix= (1/trace) * cofactor_matrix;
    //     DerivativesofEigenvalues(i,0) = DerivtivesMatrix(0,0);
    //     DerivativesofEigenvalues(i,1) = DerivtivesMatrix(1,1);
    //     DerivativesofEigenvalues(i,2) = DerivtivesMatrix(2,2);
    //     DerivativesofEigenvalues(i,3) = DerivtivesMatrix(1,2);
    //     DerivativesofEigenvalues(i,4) = DerivtivesMatrix(0,2);
    //     DerivativesofEigenvalues(i,5) = DerivtivesMatrix(0,1);
    // }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::MultiplyTensors(BoundedMatrixVoigtType& dSdE,
    const array_1d<BoundedMatrix<double, 6, 6>, 6>& dHdE,
    const Vector& StrainVector
    )
{
    KRATOS_TRY
    for (SizeType i = 0; i < VoigtSize; ++i) {
        for (SizeType j = 0; j < VoigtSize; ++j) {
            for (SizeType k = 0; k < VoigtSize; ++k) {
                dSdE(i,j) += dHdE[k](i,j)* StrainVector[k];
            }
        }
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::GetdHdk(array_1d<BoundedMatrix<double, 6, 6>, 3>& dHdk,
    const array_1d<BoundedMatrix<double, 6, 6>, 3>& dHdD,
    const BoundedMatrixType& dDdkappa
    )
{
    KRATOS_TRY
    for (SizeType i = 0; i < Dimension; ++i) {
        for (SizeType j = 0; j < VoigtSize; ++j) {
            for (SizeType m = 0; m < VoigtSize; ++m) {
                for (SizeType k = 0; k < Dimension; ++k) {
                   dHdk[i](j,m) += dHdD[k](j,m) * dDdkappa(k,i);
                }
            }
        }
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::GetdHdE(array_1d<BoundedMatrix<double, 6, 6>, 6>& dHdE,
    const array_1d<BoundedMatrix<double, 6, 6>, 3>&dHdk,
    const BoundedMatrix3x6Type& dkdE
    )
{
    KRATOS_TRY
    for (SizeType i = 0; i < VoigtSize; ++i) {
        for (SizeType j = 0; j < VoigtSize; ++j) {
            for (SizeType m = 0; m < VoigtSize; ++m) {
                for (SizeType k = 0; k < Dimension; ++k) {
                   dHdE[i](j,m) += dHdk[k](j,m) * dkdE(k,i);
                }
            }
        }
    }
    KRATOS_CATCH("")
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::GetLawFeatures(Features& rFeatures)
{
    rFeatures.mOptions.Set(THREE_DIMENSIONAL_LAW);
    rFeatures.mOptions.Set(INFINITESIMAL_STRAINS);
    rFeatures.mOptions.Set(ISOTROPIC);
    rFeatures.mStrainMeasures.push_back(StrainMeasure_Infinitesimal);
    rFeatures.mStrainSize = this->GetStrainSize();
    rFeatures.mSpaceDimension = this->WorkingSpaceDimension();
}

//************************************************************************************
//************************************************************************************



void ElasticAnisotropicDamage::save(Serializer& rSerializer) const
{
    KRATOS_SERIALIZE_SAVE_BASE_CLASS(rSerializer, ConstitutiveLaw);
    rSerializer.save("mDamageVector", mDamageVector);
}

//************************************************************************************
//************************************************************************************

void ElasticAnisotropicDamage::load(Serializer& rSerializer)
{
    KRATOS_SERIALIZE_LOAD_BASE_CLASS(rSerializer, ConstitutiveLaw);
    rSerializer.load("mDamageVector", mDamageVector);
}



} /* namespace Kratos.*/
