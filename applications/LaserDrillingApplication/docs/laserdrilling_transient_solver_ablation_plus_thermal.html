<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>laserdrilling_transient_solver_ablation_plus_thermal API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laserdrilling_transient_solver_ablation_plus_thermal</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.CreateSolver"><code class="name flex">
<span>def <span class="ident">CreateSolver</span></span>(<span>model, custom_settings)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateSolver(model, custom_settings):
    return LaserDrillingTransientSolverAblationPlusThermal(model, custom_settings)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal"><code class="flex name class">
<span>class <span class="ident">LaserDrillingTransientSolverAblationPlusThermal</span></span>
<span>(</span><span>model, custom_settings)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaserDrillingTransientSolverAblationPlusThermal(laserdrilling_transient_solver.LaserDrillingTransientSolver):
    def __init__(self, model, custom_settings):
        super().__init__(model, custom_settings)

    def SolveSolutionStep(self):
        &#34;&#34;&#34;
        TODO: Overrides LaserDrillingTransientSolver.SolveSolutionStep
        &#34;&#34;&#34;
        super(laserdrilling_transient_solver.LaserDrillingTransientSolver, self).SolveSolutionStep()

    def ComputeIonizationEnergyPerUnitVolumeThreshold(self):
        # TODO: make these quantities into parameters. Why C11_H12_O3?
        # Compute ionization energy per volume of C11_H12_O3
        E_m_H = 1312e3  #  J/mol (1st level ionization energy)
        E_m_C = 4621e3  #  J/mol (3rd level ionization energy)
        E_m_O = 3388e3  #  J/mol (2nd level ionization energy)
        W_m = 192e-3  # Kg/mol (molecular weight)
        return self.rho * (E_m_H + E_m_C + E_m_O) / W_m  # J/mm3

    def ImposeTemperatureIncreaseDueToLaserWithRefraction(self):
        # TODO: add a test that compares the case without refraction to the case with refraction at normal incidence
        X = self.list_of_decomposed_nodes_coords_X
        Y = self.list_of_decomposed_nodes_coords_Y
        print(&#34;\nPulse number&#34;, self.pulse_number, &#34;\n&#34;)

        self.hole_profile_in_Y_zero_file = open(&#34;hole_profile_in_Y_zero.txt&#34;, &#34;w&#34;)

        # Equation of the approximated hole shape (as a parabola)
        # x(y) = A * y^2 + C
        a = Y[-1]
        b = X[0]
        A = b / (a * a)
        C = -b

        for node in self.main_model_part.Nodes:
            y0 = node.Y
            x0 = A * y0 * y0 + C
            z = node.X + x0

            theta_1 = np.arctan(2 * b * y0 / (a * a))
            n1 = 1
            n2 = self.refractive_index_n
            theta_2 = np.arcsin(n1 * np.sin(theta_1) / n2)

            alpha = 0.5 * np.pi + theta_2
            l = z * np.sin(0.5 * np.pi - theta_1) / np.sin(alpha)

            y1 = y0 - l * np.sin(theta_1 - theta_2)

            incident_angle = theta_1

            delta_temp = self.TemperatureVariationDueToLaser(y1, l)
            old_temp = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
            new_temp = old_temp + delta_temp
            node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, new_temp)
            node.SetSolutionStepValue(
                KratosMultiphysics.TEMPERATURE, 1, new_temp
            )  # TODO: why override the previous time step?

            if y0 &lt; 1e-8:
                self.hole_profile_in_Y_zero_file.write(str(node.X) + &#34; &#34; + str(new_temp) + &#34;\n&#34;)

            delta_pen = self.delta_pen
            F_p = self.F_p
            omega_0 = self.omega_0

            q_energy_per_volume = (
                (1.0 / delta_pen)
                * F_p
                * np.exp(-2.0 * (y1 / omega_0) ** 2)
                * np.exp(-l / delta_pen)
                * np.cos(incident_angle)
            )
            node.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume)

            # Compute enthalpy energy per volume
            delta_temp = self.T_e - old_temp
            enthalpy_energy_per_volume = self.rho * (self.H_ev + self.cp * delta_temp)
            node.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume)

        self.hole_profile_in_Y_zero_file.close()

        for elem in self.main_model_part.Elements:
            q_energy_per_volume = elem.CalculateOnIntegrationPoints(
                LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
            )
            elem.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume[0])

            enthalpy_energy_per_volume = elem.CalculateOnIntegrationPoints(
                LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
            )
            elem.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume[0])

    def ImposeTemperatureIncreaseDueToLaser(self):
        # TODO: absorb this function into ImposeTemperatureIncreaseDueToLaserWithRefraction in the case of normal incidence
        X = self.list_of_decomposed_nodes_coords_X
        Y = self.list_of_decomposed_nodes_coords_Y
        print(
            &#34;\nPulse number&#34;, self.pulse_number, &#34;\n&#34;
        )  # TODO: Move into InitializeSolutionStep when it checks if a new pulse is added?

        # TODO: change &#39;open&#39;s to &#39;with open as xx&#39; if possible
        self.hole_profile_in_Y_zero_file = open(&#34;hole_profile_in_Y_zero.txt&#34;, &#34;w&#34;)

        # Function that returns the hole depth (x coord) as a function of the radius coord (y coord)
        F = interp1d(Y, X, bounds_error=False, fill_value=0.0)  # TODO: legacy function, update

        # TODO: vectorize this loop?
        for node in self.main_model_part.Nodes:
            &#34;&#34;&#34;
            Translate each node towards the surface, i.e., in the negative x direction
            by an amount equal to the hole&#39;s depth at the node&#39;s Y coord (Y = radius).
            In essence, shift all nodes along the x axis to the left to fill the hole.
            &#34;&#34;&#34;
            radius = node.Y
            distance_to_surface = F(radius)
            z = node.X - distance_to_surface

            # Apply the increase in temperature caused by the laser on each node
            delta_temp = self.TemperatureVariationDueToLaser(radius, z)
            old_temp = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
            new_temp = old_temp + delta_temp

            node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, new_temp)
            node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, 1, new_temp)

            if radius &lt; 1e-8:  # TODO: why this value? Make it into a variable or even a simulation parameter?
                self.hole_profile_in_Y_zero_file.write(str(node.X) + &#34; &#34; + str(new_temp) + &#34;\n&#34;)

            delta_pen = self.delta_pen
            F_p = self.F_p
            omega_0 = self.omega_0

            q_energy_per_volume = (
                (1.0 / delta_pen) * F_p * np.exp(-2.0 * (radius / omega_0) ** 2) * np.exp(-z / delta_pen)
            )  # TODO: unused?
            node.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume)

            # Compute enthalpy energy per volume
            delta_temp = self.T_e - old_temp
            enthalpy_energy_per_volume = self.rho * (self.H_ev + self.cp * delta_temp)
            node.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume)

        self.hole_profile_in_Y_zero_file.close()

        for elem in self.main_model_part.Elements:
            q_energy_per_volume_elemental = elem.CalculateOnIntegrationPoints(
                LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
            )
            elem.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume_elemental[0])

            enthalpy_energy_per_volume_elemental = elem.CalculateOnIntegrationPoints(
                LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
            )
            elem.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume_elemental[0])

    def TemperatureVariationDueToLaser(self, radius, z):
        &#34;&#34;&#34;
        Computes the temperature increase caused by the laser in a specified position.

        Parameters
        ----------
        radius: float
            The radial coordinate of the point
        z: float
            The axial coordinate of the point

        Returns
        -------
        The temperature increase in kelvins
        &#34;&#34;&#34;

        delta_pen = self.delta_pen
        F_p = self.F_p
        omega_0 = self.omega_0

        q_energy_per_volume = (
            (1.0 / delta_pen) * F_p * np.exp(-2.0 * (radius / omega_0) ** 2) * np.exp(-z / delta_pen)
        )  # * np.cos(incidence_angle)
        delta_temp = q_energy_per_volume / (self.rho * self.cp)
        return delta_temp

    def ComputePulseVolume(self):
        return 0.25 * self.delta_pen * np.pi * self.omega_0**2 * (np.log(self.F_p / (self.delta_pen * self.q_ast))) ** 2

    def RemoveElementsByAblation(self):
        &#34;&#34;&#34;
        Removes elements by ablation. (this comment is a WIP)

        Overrides LaserDrillingTransientSolver.RemoveElementsByAblation

        Parameters
        ----------
        None

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.RemoveElementsUsingEnergyPerVolumeThreshold()

        if self.print_debug_info:
            decomp_vol = self.MonitorDecomposedVolume()
            print(&#34;Actual volume loss due to laser:&#34;, decomp_vol, &#34;mm3&#34;)
            self.analytical_ablated_volume_in_n_pulses += self.ComputePulseVolume()
            print(&#34;Expected volume loss due to laser:&#34;, self.analytical_ablated_volume_in_n_pulses, &#34;mm3\n&#34;)
            relative_error = (
                100.0
                * (decomp_vol - self.analytical_ablated_volume_in_n_pulses)
                / self.analytical_ablated_volume_in_n_pulses
            )
            print(&#34;Relative error in volume (%):&#34;, relative_error, &#34;\n\n&#34;)

    def ResidualHeatStage(self):
        &#34;&#34;&#34;
        Overrides LaserDrillingTransientSolver.ResidualHeatStage
        &#34;&#34;&#34;
        pass

    def RemoveElementsUsingEnergyPerVolumeThreshold(self):
        if self.ablation_energy_fraction:
            for elem in self.main_model_part.Elements:
                q_energy_per_volume = elem.GetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME)
                enthalpy_energy_per_volume = elem.GetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME)

                # Choose the energy threshold
                &#34;&#34;&#34; 
                TODO: I think it makes sense to move the computation of energy_threshold elsewhere. However,
                why does the MATERIAL_THERMAL_ENERGY_PER_VOLUME depend on the element? Is it so that 
                different materials with different MATERIAL_THERMAL_ENERGY_PER_VOLUME can be treated 
                in the same way, without needing the code to know to which material each element belongs?
                &#34;&#34;&#34;
                if self.use_enthalpy_and_ionization:
                    ionization_energy_per_volume_threshold = self.ionizarion_energy_per_volume_threshold  # TODO: there&#39;s a typo on &#34;ionizaRion&#34; I think, but it never crashes, so it must be unused or be misspelled everywhere
                    energy_threshold = min(enthalpy_energy_per_volume, ionization_energy_per_volume_threshold)
                else:
                    energy_threshold = elem.GetValue(
                        LaserDrillingApplication.MATERIAL_THERMAL_ENERGY_PER_VOLUME
                    )  # self.q_ast # TODO: rename MATERIAL_THERMAL_ENERGY_PER_VOLUME to something more descriptive (see Woodfield 2024 for the definition of q_ast)

                # If the energy threshold is exceeded, deactivate the element
                if q_energy_per_volume &gt;= energy_threshold:
                    elem.Set(KratosMultiphysics.ACTIVE, False)
                    for node in elem.GetNodes():
                        node.SetValue(LaserDrillingApplication.DECOMPOSED_NODE, 1.0)

            # TODO: Check that the following comment is correct
            # If all the elements surrounding a &#34;center&#34; element with which they share some nodes have been deactivated (ablated),
            # the center element is also deactivated (ablated)
            # TODO: Instead of checking whether all nodes are inactive, maybe it is faster to check whether at least one node is active
            # to consider the element to still be active
            for elem in self.main_model_part.Elements:
                if elem.Is(KratosMultiphysics.ACTIVE):
                    number_of_decomposed_nodes = 0
                    for node in elem.GetNodes():
                        if node.GetValue(LaserDrillingApplication.DECOMPOSED_NODE):
                            number_of_decomposed_nodes += 1
                    if number_of_decomposed_nodes == 3:
                        elem.Set(KratosMultiphysics.ACTIVE, False)

            self.AddDecomposedNodesToSurfaceList()
            self.list_of_ablated_nodes_coords_X = self.list_of_decomposed_nodes_coords_X
            self.list_of_ablated_nodes_coords_Y = self.list_of_decomposed_nodes_coords_Y

    def Finalize(self):
        &#34;&#34;&#34;
        Overwrites LaserDrillingTransientSolver.Finalize
        &#34;&#34;&#34;
        super().Finalize()
        if self.print_hole_geometry_files:
            self.hole_theoretical_profile_file = open(&#34;hole_theoretical_profile.txt&#34;, &#34;w&#34;)
            for i, node_Y in enumerate(self.hole_theoretical_Y_coords):
                if self.hole_theoretical_X_coords[i]:
                    self.hole_theoretical_profile_file.write(
                        str(node_Y) + &#34; &#34; + str(-self.hole_theoretical_X_coords[i]) + &#34;\n&#34;
                    )
            self.hole_theoretical_profile_file.close()

            self.hole_theoretical_profile_file_no_z_offset_variation = open(
                &#34;hole_theoretical_profile_no_z_offset_variation.txt&#34;, &#34;w&#34;
            )
            for i, node_Y in enumerate(self.one_pulse_hole_theoretical_Y_coords):
                if self.one_pulse_hole_theoretical_X_coords[i]:
                    self.hole_theoretical_profile_file_no_z_offset_variation.write(
                        str(node_Y) + &#34; &#34; + str(-self.pulse_number * self.one_pulse_hole_theoretical_X_coords[i]) + &#34;\n&#34;
                    )
            self.hole_theoretical_profile_file_no_z_offset_variation.close()

            a = self.list_of_ablated_nodes_coords_Y[-1]
            b = self.list_of_ablated_nodes_coords_X[0]
            A = b / (a * a)
            C = -b

            parabola_Y_coords = np.linspace(0.0, a, 101)
            self.hole_parabolical_profile = open(&#34;hole_parabolical_profile.txt&#34;, &#34;w&#34;)
            for Y_coords in parabola_Y_coords:
                X_coords = A * Y_coords * Y_coords + C
                self.hole_parabolical_profile.write(str(Y_coords) + &#34; &#34; + str(X_coords) + &#34;\n&#34;)
            self.hole_parabolical_profile.close()</code></pre>
</details>
<div class="desc"><p>The transient class for convection-diffusion solvers.</p>
<p>Public member variables:
transient_settings &ndash; settings for the implicit dynamic solvers.</p>
<p>See convection_diffusion_solver.py for more information.</p>
<p>The constructor of the PythonSolver-Object.</p>
<p>It is intended to be called from the constructor
of deriving classes:
super().<strong>init</strong>(settings)</p>
<p>Keyword arguments:
self &ndash; It signifies an instance of a class.
model &ndash; The Model to be used
settings &ndash; The solver settings used</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>KratosMultiphysics.LaserDrillingApplication.laserdrilling_transient_solver.LaserDrillingTransientSolver</li>
<li>KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_transient_solver.ConvectionDiffusionTransientSolver</li>
<li>KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_solver.ConvectionDiffusionSolver</li>
<li>KratosMultiphysics.python_solver.PythonSolver</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputeIonizationEnergyPerUnitVolumeThreshold"><code class="name flex">
<span>def <span class="ident">ComputeIonizationEnergyPerUnitVolumeThreshold</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ComputeIonizationEnergyPerUnitVolumeThreshold(self):
    # TODO: make these quantities into parameters. Why C11_H12_O3?
    # Compute ionization energy per volume of C11_H12_O3
    E_m_H = 1312e3  #  J/mol (1st level ionization energy)
    E_m_C = 4621e3  #  J/mol (3rd level ionization energy)
    E_m_O = 3388e3  #  J/mol (2nd level ionization energy)
    W_m = 192e-3  # Kg/mol (molecular weight)
    return self.rho * (E_m_H + E_m_C + E_m_O) / W_m  # J/mm3</code></pre>
</details>
<div class="desc"><p>Must be implemented by child classes.</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputePulseVolume"><code class="name flex">
<span>def <span class="ident">ComputePulseVolume</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ComputePulseVolume(self):
    return 0.25 * self.delta_pen * np.pi * self.omega_0**2 * (np.log(self.F_p / (self.delta_pen * self.q_ast))) ** 2</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.Finalize"><code class="name flex">
<span>def <span class="ident">Finalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Finalize(self):
    &#34;&#34;&#34;
    Overwrites LaserDrillingTransientSolver.Finalize
    &#34;&#34;&#34;
    super().Finalize()
    if self.print_hole_geometry_files:
        self.hole_theoretical_profile_file = open(&#34;hole_theoretical_profile.txt&#34;, &#34;w&#34;)
        for i, node_Y in enumerate(self.hole_theoretical_Y_coords):
            if self.hole_theoretical_X_coords[i]:
                self.hole_theoretical_profile_file.write(
                    str(node_Y) + &#34; &#34; + str(-self.hole_theoretical_X_coords[i]) + &#34;\n&#34;
                )
        self.hole_theoretical_profile_file.close()

        self.hole_theoretical_profile_file_no_z_offset_variation = open(
            &#34;hole_theoretical_profile_no_z_offset_variation.txt&#34;, &#34;w&#34;
        )
        for i, node_Y in enumerate(self.one_pulse_hole_theoretical_Y_coords):
            if self.one_pulse_hole_theoretical_X_coords[i]:
                self.hole_theoretical_profile_file_no_z_offset_variation.write(
                    str(node_Y) + &#34; &#34; + str(-self.pulse_number * self.one_pulse_hole_theoretical_X_coords[i]) + &#34;\n&#34;
                )
        self.hole_theoretical_profile_file_no_z_offset_variation.close()

        a = self.list_of_ablated_nodes_coords_Y[-1]
        b = self.list_of_ablated_nodes_coords_X[0]
        A = b / (a * a)
        C = -b

        parabola_Y_coords = np.linspace(0.0, a, 101)
        self.hole_parabolical_profile = open(&#34;hole_parabolical_profile.txt&#34;, &#34;w&#34;)
        for Y_coords in parabola_Y_coords:
            X_coords = A * Y_coords * Y_coords + C
            self.hole_parabolical_profile.write(str(Y_coords) + &#34; &#34; + str(X_coords) + &#34;\n&#34;)
        self.hole_parabolical_profile.close()</code></pre>
</details>
<div class="desc"><p>Overwrites LaserDrillingTransientSolver.Finalize</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaser"><code class="name flex">
<span>def <span class="ident">ImposeTemperatureIncreaseDueToLaser</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ImposeTemperatureIncreaseDueToLaser(self):
    # TODO: absorb this function into ImposeTemperatureIncreaseDueToLaserWithRefraction in the case of normal incidence
    X = self.list_of_decomposed_nodes_coords_X
    Y = self.list_of_decomposed_nodes_coords_Y
    print(
        &#34;\nPulse number&#34;, self.pulse_number, &#34;\n&#34;
    )  # TODO: Move into InitializeSolutionStep when it checks if a new pulse is added?

    # TODO: change &#39;open&#39;s to &#39;with open as xx&#39; if possible
    self.hole_profile_in_Y_zero_file = open(&#34;hole_profile_in_Y_zero.txt&#34;, &#34;w&#34;)

    # Function that returns the hole depth (x coord) as a function of the radius coord (y coord)
    F = interp1d(Y, X, bounds_error=False, fill_value=0.0)  # TODO: legacy function, update

    # TODO: vectorize this loop?
    for node in self.main_model_part.Nodes:
        &#34;&#34;&#34;
        Translate each node towards the surface, i.e., in the negative x direction
        by an amount equal to the hole&#39;s depth at the node&#39;s Y coord (Y = radius).
        In essence, shift all nodes along the x axis to the left to fill the hole.
        &#34;&#34;&#34;
        radius = node.Y
        distance_to_surface = F(radius)
        z = node.X - distance_to_surface

        # Apply the increase in temperature caused by the laser on each node
        delta_temp = self.TemperatureVariationDueToLaser(radius, z)
        old_temp = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
        new_temp = old_temp + delta_temp

        node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, new_temp)
        node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, 1, new_temp)

        if radius &lt; 1e-8:  # TODO: why this value? Make it into a variable or even a simulation parameter?
            self.hole_profile_in_Y_zero_file.write(str(node.X) + &#34; &#34; + str(new_temp) + &#34;\n&#34;)

        delta_pen = self.delta_pen
        F_p = self.F_p
        omega_0 = self.omega_0

        q_energy_per_volume = (
            (1.0 / delta_pen) * F_p * np.exp(-2.0 * (radius / omega_0) ** 2) * np.exp(-z / delta_pen)
        )  # TODO: unused?
        node.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume)

        # Compute enthalpy energy per volume
        delta_temp = self.T_e - old_temp
        enthalpy_energy_per_volume = self.rho * (self.H_ev + self.cp * delta_temp)
        node.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume)

    self.hole_profile_in_Y_zero_file.close()

    for elem in self.main_model_part.Elements:
        q_energy_per_volume_elemental = elem.CalculateOnIntegrationPoints(
            LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
        )
        elem.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume_elemental[0])

        enthalpy_energy_per_volume_elemental = elem.CalculateOnIntegrationPoints(
            LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
        )
        elem.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume_elemental[0])</code></pre>
</details>
<div class="desc"><p>Increases the temperature as an effect of the energy deposition by the laser pulse.
Does not take into account the refraction of the ray at the boundary air-solid.
Must be implemented by child classes.</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaserWithRefraction"><code class="name flex">
<span>def <span class="ident">ImposeTemperatureIncreaseDueToLaserWithRefraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ImposeTemperatureIncreaseDueToLaserWithRefraction(self):
    # TODO: add a test that compares the case without refraction to the case with refraction at normal incidence
    X = self.list_of_decomposed_nodes_coords_X
    Y = self.list_of_decomposed_nodes_coords_Y
    print(&#34;\nPulse number&#34;, self.pulse_number, &#34;\n&#34;)

    self.hole_profile_in_Y_zero_file = open(&#34;hole_profile_in_Y_zero.txt&#34;, &#34;w&#34;)

    # Equation of the approximated hole shape (as a parabola)
    # x(y) = A * y^2 + C
    a = Y[-1]
    b = X[0]
    A = b / (a * a)
    C = -b

    for node in self.main_model_part.Nodes:
        y0 = node.Y
        x0 = A * y0 * y0 + C
        z = node.X + x0

        theta_1 = np.arctan(2 * b * y0 / (a * a))
        n1 = 1
        n2 = self.refractive_index_n
        theta_2 = np.arcsin(n1 * np.sin(theta_1) / n2)

        alpha = 0.5 * np.pi + theta_2
        l = z * np.sin(0.5 * np.pi - theta_1) / np.sin(alpha)

        y1 = y0 - l * np.sin(theta_1 - theta_2)

        incident_angle = theta_1

        delta_temp = self.TemperatureVariationDueToLaser(y1, l)
        old_temp = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
        new_temp = old_temp + delta_temp
        node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, new_temp)
        node.SetSolutionStepValue(
            KratosMultiphysics.TEMPERATURE, 1, new_temp
        )  # TODO: why override the previous time step?

        if y0 &lt; 1e-8:
            self.hole_profile_in_Y_zero_file.write(str(node.X) + &#34; &#34; + str(new_temp) + &#34;\n&#34;)

        delta_pen = self.delta_pen
        F_p = self.F_p
        omega_0 = self.omega_0

        q_energy_per_volume = (
            (1.0 / delta_pen)
            * F_p
            * np.exp(-2.0 * (y1 / omega_0) ** 2)
            * np.exp(-l / delta_pen)
            * np.cos(incident_angle)
        )
        node.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume)

        # Compute enthalpy energy per volume
        delta_temp = self.T_e - old_temp
        enthalpy_energy_per_volume = self.rho * (self.H_ev + self.cp * delta_temp)
        node.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume)

    self.hole_profile_in_Y_zero_file.close()

    for elem in self.main_model_part.Elements:
        q_energy_per_volume = elem.CalculateOnIntegrationPoints(
            LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
        )
        elem.SetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME, q_energy_per_volume[0])

        enthalpy_energy_per_volume = elem.CalculateOnIntegrationPoints(
            LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, self.main_model_part.ProcessInfo
        )
        elem.SetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME, enthalpy_energy_per_volume[0])</code></pre>
</details>
<div class="desc"><p>Increases the temperature as an effect of the energy deposition by the laser pulse.
Takes into account the refraction of the ray at the boundary air-solid.
Must be implemented by child classes.</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsByAblation"><code class="name flex">
<span>def <span class="ident">RemoveElementsByAblation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveElementsByAblation(self):
    &#34;&#34;&#34;
    Removes elements by ablation. (this comment is a WIP)

    Overrides LaserDrillingTransientSolver.RemoveElementsByAblation

    Parameters
    ----------
    None

    Returns
    -------
    None
    &#34;&#34;&#34;
    self.RemoveElementsUsingEnergyPerVolumeThreshold()

    if self.print_debug_info:
        decomp_vol = self.MonitorDecomposedVolume()
        print(&#34;Actual volume loss due to laser:&#34;, decomp_vol, &#34;mm3&#34;)
        self.analytical_ablated_volume_in_n_pulses += self.ComputePulseVolume()
        print(&#34;Expected volume loss due to laser:&#34;, self.analytical_ablated_volume_in_n_pulses, &#34;mm3\n&#34;)
        relative_error = (
            100.0
            * (decomp_vol - self.analytical_ablated_volume_in_n_pulses)
            / self.analytical_ablated_volume_in_n_pulses
        )
        print(&#34;Relative error in volume (%):&#34;, relative_error, &#34;\n\n&#34;)</code></pre>
</details>
<div class="desc"><p>Removes elements by ablation. (this comment is a WIP)</p>
<p>Overrides LaserDrillingTransientSolver.RemoveElementsByAblation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsUsingEnergyPerVolumeThreshold"><code class="name flex">
<span>def <span class="ident">RemoveElementsUsingEnergyPerVolumeThreshold</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveElementsUsingEnergyPerVolumeThreshold(self):
    if self.ablation_energy_fraction:
        for elem in self.main_model_part.Elements:
            q_energy_per_volume = elem.GetValue(LaserDrillingApplication.THERMAL_ENERGY_PER_VOLUME)
            enthalpy_energy_per_volume = elem.GetValue(LaserDrillingApplication.ENTHALPY_ENERGY_PER_VOLUME)

            # Choose the energy threshold
            &#34;&#34;&#34; 
            TODO: I think it makes sense to move the computation of energy_threshold elsewhere. However,
            why does the MATERIAL_THERMAL_ENERGY_PER_VOLUME depend on the element? Is it so that 
            different materials with different MATERIAL_THERMAL_ENERGY_PER_VOLUME can be treated 
            in the same way, without needing the code to know to which material each element belongs?
            &#34;&#34;&#34;
            if self.use_enthalpy_and_ionization:
                ionization_energy_per_volume_threshold = self.ionizarion_energy_per_volume_threshold  # TODO: there&#39;s a typo on &#34;ionizaRion&#34; I think, but it never crashes, so it must be unused or be misspelled everywhere
                energy_threshold = min(enthalpy_energy_per_volume, ionization_energy_per_volume_threshold)
            else:
                energy_threshold = elem.GetValue(
                    LaserDrillingApplication.MATERIAL_THERMAL_ENERGY_PER_VOLUME
                )  # self.q_ast # TODO: rename MATERIAL_THERMAL_ENERGY_PER_VOLUME to something more descriptive (see Woodfield 2024 for the definition of q_ast)

            # If the energy threshold is exceeded, deactivate the element
            if q_energy_per_volume &gt;= energy_threshold:
                elem.Set(KratosMultiphysics.ACTIVE, False)
                for node in elem.GetNodes():
                    node.SetValue(LaserDrillingApplication.DECOMPOSED_NODE, 1.0)

        # TODO: Check that the following comment is correct
        # If all the elements surrounding a &#34;center&#34; element with which they share some nodes have been deactivated (ablated),
        # the center element is also deactivated (ablated)
        # TODO: Instead of checking whether all nodes are inactive, maybe it is faster to check whether at least one node is active
        # to consider the element to still be active
        for elem in self.main_model_part.Elements:
            if elem.Is(KratosMultiphysics.ACTIVE):
                number_of_decomposed_nodes = 0
                for node in elem.GetNodes():
                    if node.GetValue(LaserDrillingApplication.DECOMPOSED_NODE):
                        number_of_decomposed_nodes += 1
                if number_of_decomposed_nodes == 3:
                    elem.Set(KratosMultiphysics.ACTIVE, False)

        self.AddDecomposedNodesToSurfaceList()
        self.list_of_ablated_nodes_coords_X = self.list_of_decomposed_nodes_coords_X
        self.list_of_ablated_nodes_coords_Y = self.list_of_decomposed_nodes_coords_Y</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ResidualHeatStage"><code class="name flex">
<span>def <span class="ident">ResidualHeatStage</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ResidualHeatStage(self):
    &#34;&#34;&#34;
    Overrides LaserDrillingTransientSolver.ResidualHeatStage
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Overrides LaserDrillingTransientSolver.ResidualHeatStage</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.SolveSolutionStep"><code class="name flex">
<span>def <span class="ident">SolveSolutionStep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveSolutionStep(self):
    &#34;&#34;&#34;
    TODO: Overrides LaserDrillingTransientSolver.SolveSolutionStep
    &#34;&#34;&#34;
    super(laserdrilling_transient_solver.LaserDrillingTransientSolver, self).SolveSolutionStep()</code></pre>
</details>
<div class="desc"><p>TODO: Overrides LaserDrillingTransientSolver.SolveSolutionStep</p></div>
</dd>
<dt id="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.TemperatureVariationDueToLaser"><code class="name flex">
<span>def <span class="ident">TemperatureVariationDueToLaser</span></span>(<span>self, radius, z)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TemperatureVariationDueToLaser(self, radius, z):
    &#34;&#34;&#34;
    Computes the temperature increase caused by the laser in a specified position.

    Parameters
    ----------
    radius: float
        The radial coordinate of the point
    z: float
        The axial coordinate of the point

    Returns
    -------
    The temperature increase in kelvins
    &#34;&#34;&#34;

    delta_pen = self.delta_pen
    F_p = self.F_p
    omega_0 = self.omega_0

    q_energy_per_volume = (
        (1.0 / delta_pen) * F_p * np.exp(-2.0 * (radius / omega_0) ** 2) * np.exp(-z / delta_pen)
    )  # * np.cos(incidence_angle)
    delta_temp = q_energy_per_volume / (self.rho * self.cp)
    return delta_temp</code></pre>
</details>
<div class="desc"><p>Computes the temperature increase caused by the laser in a specified position.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radial coordinate of the point</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>The axial coordinate of the point</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The temperature increase in kelvins</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.CreateSolver" href="#laserdrilling_transient_solver_ablation_plus_thermal.CreateSolver">CreateSolver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal">LaserDrillingTransientSolverAblationPlusThermal</a></code></h4>
<ul class="">
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputeIonizationEnergyPerUnitVolumeThreshold" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputeIonizationEnergyPerUnitVolumeThreshold">ComputeIonizationEnergyPerUnitVolumeThreshold</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputePulseVolume" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ComputePulseVolume">ComputePulseVolume</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.Finalize" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.Finalize">Finalize</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaser" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaser">ImposeTemperatureIncreaseDueToLaser</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaserWithRefraction" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ImposeTemperatureIncreaseDueToLaserWithRefraction">ImposeTemperatureIncreaseDueToLaserWithRefraction</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsByAblation" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsByAblation">RemoveElementsByAblation</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsUsingEnergyPerVolumeThreshold" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.RemoveElementsUsingEnergyPerVolumeThreshold">RemoveElementsUsingEnergyPerVolumeThreshold</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ResidualHeatStage" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.ResidualHeatStage">ResidualHeatStage</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.SolveSolutionStep" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.SolveSolutionStep">SolveSolutionStep</a></code></li>
<li><code><a title="laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.TemperatureVariationDueToLaser" href="#laserdrilling_transient_solver_ablation_plus_thermal.LaserDrillingTransientSolverAblationPlusThermal.TemperatureVariationDueToLaser">TemperatureVariationDueToLaser</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
