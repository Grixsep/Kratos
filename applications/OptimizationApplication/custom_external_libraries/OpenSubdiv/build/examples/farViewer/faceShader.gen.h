"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#if __VERSION__ < 420\n"
"    #define centroid\n"
"#endif\n"
"\n"
"layout(std140) uniform Transform {\n"
"    mat4 ModelViewMatrix;\n"
"    mat4 ProjectionMatrix;\n"
"    mat4 ModelViewProjectionMatrix;\n"
"};\n"
"\n"
"struct ControlVertex {\n"
"    vec4 position;\n"
"    centroid vec4 patchCoord; // u, v, level, faceID\n"
"    ivec4 ptexInfo;           // U offset, V offset, 2^ptexlevel', rotation\n"
"    ivec3 clipFlag;\n"
"};\n"
"\n"
"struct OutputVertex {\n"
"    vec4 position;\n"
"    vec3 normal;\n"
"    centroid vec4 patchCoord; // u, v, level, faceID\n"
"    centroid vec2 tessCoord;  // tesscoord.st\n"
"    vec3 tangent;\n"
"    vec3 bitangent;\n"
"};\n"
"\n"
"//--------------------------------------------------------------\n"
"// Vertex Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef VERTEX_SHADER\n"
"\n"
"layout (location=0) in vec4 position;\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = ModelViewMatrix * position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"//--------------------------------------------------------------\n"
"// Geometry Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef GEOMETRY_SHADER\n"
"\n"
"layout(lines_adjacency) in;\n"
"\n"
"#define EDGE_VERTS 4\n"
"\n"
"layout(triangle_strip, max_vertices = EDGE_VERTS) out;\n"
"\n"
"in block {\n"
"    OutputVertex v;\n"
"} inpt[EDGE_VERTS];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"} outpt;\n"
"\n"
"void emit(int index, vec3 normal, vec2 uv)\n"
"{\n"
"    outpt.v.position = inpt[index].v.position;\n"
"    outpt.v.normal = normal;\n"
"    outpt.v.tessCoord = uv;\n"
"\n"
"    gl_Position = ProjectionMatrix * inpt[index].v.position;\n"
"    EmitVertex();\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    gl_PrimitiveID = gl_PrimitiveIDIn;\n"
"\n"
"    vec3 A = (inpt[0].v.position - inpt[1].v.position).xyz;\n"
"    vec3 B = (inpt[3].v.position - inpt[1].v.position).xyz;\n"
"    vec3 C = (inpt[2].v.position - inpt[1].v.position).xyz;\n"
"    vec3 n0 = normalize(cross(B, A));\n"
"\n"
"    emit(0, n0, vec2(0.0,0.0));\n"
"    emit(1, n0, vec2(0.0,1.0));\n"
"    emit(3, n0, vec2(1.0,0.0));\n"
"    emit(2, n0, vec2(1.0,1.0));\n"
"\n"
"    EndPrimitive();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//--------------------------------------------------------------\n"
"// Fragment Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"in block {\n"
"    OutputVertex v;\n"
"} inpt;\n"
"\n"
"out vec4 outColor;\n"
"out vec3 outNormal;\n"
"\n"
"#define NUM_LIGHTS 2\n"
"\n"
"struct LightSource {\n"
"    vec4 position;\n"
"    vec4 ambient;\n"
"    vec4 diffuse;\n"
"    vec4 specular;\n"
"};\n"
"\n"
"layout(std140) uniform Lighting {\n"
"    LightSource lightSource[NUM_LIGHTS];\n"
"};\n"
"\n"
"uniform vec4 diffuseColor = vec4(1);\n"
"uniform vec4 ambientColor = vec4(1);\n"
"\n"
"uniform samplerBuffer faceColors;\n"
"uniform sampler2D faceTexture;\n"
"\n"
"vec4\n"
"lighting(vec4 diffuse, vec3 Peye, vec3 Neye)\n"
"{\n"
"    vec4 color = vec4(0);\n"
"\n"
"    for (int i = 0; i < NUM_LIGHTS; ++i) {\n"
"\n"
"        vec4 Plight = lightSource[i].position;\n"
"\n"
"        vec3 l = (Plight.w == 0.0)\n"
"                    ? normalize(Plight.xyz) : normalize(Plight.xyz - Peye);\n"
"\n"
"        vec3 n = normalize(Neye);\n"
"        vec3 h = normalize(l + vec3(0,0,1));    // directional viewer\n"
"\n"
"        float d = max(0.0, dot(n, l));\n"
"        float s = pow(max(0.0, dot(n, h)), 500.0f);\n"
"\n"
"        color +=       lightSource[i].ambient * ambientColor\n"
"                 + d * lightSource[i].diffuse * diffuse\n"
"                 + s * lightSource[i].specular;\n"
"    }\n"
"\n"
"    color.a = 1;\n"
"    return color;\n"
"}\n"
"\n"
"void\n"
"main()\n"
"{\n"
"    vec3 N = (gl_FrontFacing ? inpt.v.normal : -inpt.v.normal);\n"
"\n"
"    vec4 faceColor = texelFetch(faceColors, gl_PrimitiveID);\n"
"    \n"
"    vec4 tex = texture(faceTexture, inpt.v.tessCoord);\n"
"\n"
"    vec4 Cf = lighting(diffuseColor * faceColor * tex, inpt.v.position.xyz, N);\n"
"\n"
"    outColor = Cf;\n"
"    outNormal = N;\n"
"}\n"
"\n"
"#endif\n"
"\n"
