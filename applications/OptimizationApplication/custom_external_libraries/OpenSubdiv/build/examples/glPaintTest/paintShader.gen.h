"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"vec4 PTexLookup(vec4 patchCoord,\n"
"                sampler2DArray data,\n"
"                samplerBuffer packings,\n"
"                isamplerBuffer pages)\n"
"{\n"
"    vec2 uv = patchCoord.xy;\n"
"    int faceID = int(patchCoord.w);\n"
"    int page = texelFetch(pages, faceID).x;\n"
"    vec4 packing = texelFetch(packings, faceID);\n"
"    vec3 coords = vec3( packing.x + uv.x * packing.z,\n"
"                        packing.y + uv.y * packing.w,\n"
"                        page);\n"
"\n"
"    return texture(data, coords);\n"
"}\n"
"\n"
"uniform sampler2DArray textureImage_Data;\n"
"uniform samplerBuffer textureImage_Packing;\n"
"uniform isamplerBuffer textureImage_Pages;\n"
"\n"
"vec4 displacement(vec4 position, vec3 normal, vec4 patchCoord)\n"
"{\n"
"    float disp = PTexLookup(patchCoord,\n"
"                            textureImage_Data,\n"
"                            textureImage_Packing,\n"
"                            textureImage_Pages).x;\n"
"    return position + 0.01*vec4(disp * normal, 0);\n"
"}\n"
"\n"
"//--------------------------------------------------------------\n"
"// Uniform Blocks\n"
"//--------------------------------------------------------------\n"
"\n"
"layout(std140) uniform Transform {\n"
"    mat4 ModelViewMatrix;\n"
"    mat4 ProjectionMatrix;\n"
"    mat4 ModelViewProjectionMatrix;\n"
"    mat4 ModelViewInverseMatrix;\n"
"    mat4 ProjectionWithoutPickMatrix;\n"
"};\n"
"\n"
"layout(std140) uniform Tessellation {\n"
"    float TessLevel;\n"
"};\n"
"\n"
"uniform int GregoryQuadOffsetBase;\n"
"uniform int PrimitiveIdBase;\n"
"\n"
"//--------------------------------------------------------------\n"
"// Osd external functions\n"
"//--------------------------------------------------------------\n"
"\n"
"mat4 OsdModelViewMatrix()\n"
"{\n"
"    return ModelViewMatrix;\n"
"}\n"
"mat4 OsdProjectionMatrix()\n"
"{\n"
"    return ProjectionMatrix;\n"
"}\n"
"mat4 OsdModelViewProjectionMatrix()\n"
"{\n"
"    return ModelViewProjectionMatrix;\n"
"}\n"
"float OsdTessLevel()\n"
"{\n"
"    return TessLevel;\n"
"}\n"
"int OsdGregoryQuadOffsetBase()\n"
"{\n"
"    return GregoryQuadOffsetBase;\n"
"}\n"
"int OsdPrimitiveIdBase()\n"
"{\n"
"    return PrimitiveIdBase;\n"
"}\n"
"\n"
"//--------------------------------------------------------------\n"
"// Vertex Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef VERTEX_SHADER\n"
"\n"
"layout (location=0) in vec4 position;\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = ModelViewMatrix * position;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//--------------------------------------------------------------\n"
"// Geometry Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef GEOMETRY_SHADER\n"
"\n"
"layout(triangles) in;\n"
"\n"
"layout(triangle_strip, max_vertices = 3) out;\n"
"\n"
"in block {\n"
"   OutputVertex v;\n"
"} inpt[3];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    vec4 depthPosition;\n"
"} outpt;\n"
"\n"
"void emit(int index, vec4 position)\n"
"{\n"
"    vec2 uv = vec2(inpt[index].v.patchCoord.xy);\n"
"    outpt.v.position    = ProjectionMatrix * position;\n"
"    outpt.depthPosition = ProjectionWithoutPickMatrix * position;\n"
"    outpt.v.patchCoord  = inpt[index].v.patchCoord;\n"
"    gl_Position          = vec4(uv*2-vec2(1.0), 0, 1);\n"
"    EmitVertex();\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    gl_PrimitiveID = gl_PrimitiveIDIn;\n"
"\n"
"    vec4 patchCoord[3];\n"
"    vec4 position[3];\n"
"\n"
"    // patch coords are computed in tessellation shader\n"
"    patchCoord[0] = inpt[0].v.patchCoord;\n"
"    patchCoord[1] = inpt[1].v.patchCoord;\n"
"    patchCoord[2] = inpt[2].v.patchCoord;\n"
"\n"
"#ifdef USE_PTEX_DISPLACEMENT\n"
"    position[0] = displacement(inpt[0].v.position, inpt[0].v.normal, patchCoord[0]);\n"
"    position[1] = displacement(inpt[1].v.position, inpt[1].v.normal, patchCoord[1]);\n"
"    position[2] = displacement(inpt[2].v.position, inpt[2].v.normal, patchCoord[2]);\n"
"#else\n"
"    position[0] = inpt[0].v.position;\n"
"    position[1] = inpt[1].v.position;\n"
"    position[2] = inpt[2].v.position;\n"
"#endif\n"
"\n"
"    emit(0, position[0]);\n"
"    emit(1, position[1]);\n"
"    emit(2, position[2]);\n"
"    EndPrimitive();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//--------------------------------------------------------------\n"
"// Fragment Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"in block {\n"
"    OutputVertex v;\n"
"    vec4 depthPosition;\n"
"} inpt;\n"
"\n"
"layout(size1x32) uniform image2DArray outTextureImage;\n"
"uniform sampler2D paintTexture;\n"
"uniform sampler2D depthTexture;\n"
"uniform int imageSize = 256;\n"
"\n"
"void\n"
"main()\n"
"{\n"
"    vec4 p = inpt.v.position;\n"
"    p.xyz /= p.w;\n"
"\n"
"    vec4 wp = inpt.depthPosition;\n"
"    wp.z -= 0.001;\n"
"    wp.xyz /= wp.w;\n"
"\n"
"    vec4 c = texture(paintTexture, p.xy*0.5+0.5);\n"
"    float depth = texture(depthTexture, wp.xy*0.5+0.5).x;\n"
"    if (wp.z*0.5+0.5 >= depth) return;\n"
"    \n"
"    ivec3 pos = ivec3(inpt.v.patchCoord.x * imageSize,\n"
"                      inpt.v.patchCoord.y * imageSize,\n"
"                      int(inpt.v.patchCoord.w));\n"
"\n"
"    vec4 d = imageLoad(outTextureImage, pos);\n"
"    c = c + d;\n"
"    imageStore(outTextureImage, pos, c);\n"
"    discard;\n"
"}\n"
"\n"
"#endif\n"
"\n"
