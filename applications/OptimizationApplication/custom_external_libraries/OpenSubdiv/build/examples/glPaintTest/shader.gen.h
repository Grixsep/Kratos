"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"vec4 PTexLookup(vec4 patchCoord,\n"
"                sampler2DArray data,\n"
"                samplerBuffer packings,\n"
"                isamplerBuffer pages)\n"
"{\n"
"    vec2 uv = patchCoord.xy;\n"
"    int faceID = int(patchCoord.w);\n"
"    int page = texelFetch(pages, faceID).x;\n"
"    vec4 packing = texelFetch(packings, faceID);\n"
"    vec3 coords = vec3( packing.x + uv.x * packing.z,\n"
"                        packing.y + uv.y * packing.w,\n"
"                        page);\n"
"\n"
"    return texture(data, coords);\n"
"}\n"
"\n"
"uniform sampler2DArray textureImage_Data;\n"
"uniform samplerBuffer textureImage_Packing;\n"
"uniform isamplerBuffer textureImage_Pages;\n"
"\n"
"vec4 displacement(vec4 position, vec3 normal, vec4 patchCoord)\n"
"{\n"
"    float disp = PTexLookup(patchCoord,\n"
"                            textureImage_Data,\n"
"                            textureImage_Packing,\n"
"                            textureImage_Pages).x;\n"
"    return position + 0.01*vec4(disp * normal, 0);\n"
"}\n"
"\n"
"//--------------------------------------------------------------\n"
"// Uniform Blocks\n"
"//--------------------------------------------------------------\n"
"\n"
"layout(std140) uniform Transform {\n"
"    mat4 ModelViewMatrix;\n"
"    mat4 ProjectionMatrix;\n"
"    mat4 ModelViewProjectionMatrix;\n"
"    mat4 ModelViewInverseMatrix;\n"
"    mat4 ProjectionWithoutPickMatrix;\n"
"};\n"
"\n"
"layout(std140) uniform Tessellation {\n"
"    float TessLevel;\n"
"};\n"
"\n"
"uniform int GregoryQuadOffsetBase;\n"
"uniform int PrimitiveIdBase;\n"
"\n"
"//--------------------------------------------------------------\n"
"// Osd external functions\n"
"//--------------------------------------------------------------\n"
"\n"
"mat4 OsdModelViewMatrix()\n"
"{\n"
"    return ModelViewMatrix;\n"
"}\n"
"mat4 OsdProjectionMatrix()\n"
"{\n"
"    return ProjectionMatrix;\n"
"}\n"
"mat4 OsdModelViewProjectionMatrix()\n"
"{\n"
"    return ModelViewProjectionMatrix;\n"
"}\n"
"float OsdTessLevel()\n"
"{\n"
"    return TessLevel;\n"
"}\n"
"int OsdGregoryQuadOffsetBase()\n"
"{\n"
"    return GregoryQuadOffsetBase;\n"
"}\n"
"int OsdPrimitiveIdBase()\n"
"{\n"
"    return PrimitiveIdBase;\n"
"}\n"
"int OsdBaseVertex()\n"
"{\n"
"    return 0;\n"
"}\n"
"\n"
"//--------------------------------------------------------------\n"
"// Geometry Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef GEOMETRY_SHADER\n"
"\n"
"    layout(triangles) in;\n"
"\n"
"    layout(triangle_strip, max_vertices = 3) out;\n"
"\n"
"    #define EDGE_VERTS 3\n"
"\n"
"    in block {\n"
"        OutputVertex v;\n"
"    } inpt[3];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    noperspective out vec4 edgeDistance;\n"
"} outpt;\n"
"\n"
"void emit(int index, vec4 position, vec3 normal, vec4 patchCoord)\n"
"{\n"
"    outpt.v.position = position;\n"
"    outpt.v.patchCoord = patchCoord;\n"
"    outpt.v.normal = normal;\n"
"\n"
"    gl_Position = ProjectionMatrix * outpt.v.position;\n"
"    EmitVertex();\n"
"}\n"
"\n"
"const float VIEWPORT_SCALE = 1024.0; // XXXdyu\n"
"\n"
"float edgeDistance(vec4 p, vec4 p0, vec4 p1)\n"
"{\n"
"    return VIEWPORT_SCALE *\n"
"        abs((p.x - p0.x) * (p1.y - p0.y) -\n"
"            (p.y - p0.y) * (p1.x - p0.x)) / length(p1.xy - p0.xy);\n"
"}\n"
"\n"
"void emit(int index, vec4 position, vec3 normal, vec4 patchCoord, vec4 edgeVerts[EDGE_VERTS])\n"
"{\n"
"    outpt.edgeDistance[0] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[0], edgeVerts[1]);\n"
"    outpt.edgeDistance[1] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[1], edgeVerts[2]);\n"
"    outpt.edgeDistance[2] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[0]);\n"
"    emit(index, position, normal, patchCoord);\n"
"}\n"
"\n"
"// --------------------------------------\n"
"\n"
"void main()\n"
"{\n"
"    gl_PrimitiveID = gl_PrimitiveIDIn;\n"
"\n"
"    vec4 position[3];\n"
"    vec4 patchCoord[3];\n"
"    vec3 normal[3];\n"
"\n"
"    // patch coords are computed in tessellation shader\n"
"    patchCoord[0] = inpt[0].v.patchCoord;\n"
"    patchCoord[1] = inpt[1].v.patchCoord;\n"
"    patchCoord[2] = inpt[2].v.patchCoord;\n"
"\n"
"#ifdef USE_PTEX_DISPLACEMENT\n"
"    position[0] = displacement(inpt[0].v.position, inpt[0].v.normal, patchCoord[0]);\n"
"    position[1] = displacement(inpt[1].v.position, inpt[1].v.normal, patchCoord[1]);\n"
"    position[2] = displacement(inpt[2].v.position, inpt[2].v.normal, patchCoord[2]);\n"
"#else\n"
"    position[0] = inpt[0].v.position;\n"
"    position[1] = inpt[1].v.position;\n"
"    position[2] = inpt[2].v.position;\n"
"#endif\n"
"\n"
"    normal[0] = inpt[0].v.normal;\n"
"    normal[1] = inpt[1].v.normal;\n"
"    normal[2] = inpt[2].v.normal;\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"    vec4 edgeVerts[EDGE_VERTS];\n"
"    edgeVerts[0] = ProjectionMatrix * inpt[0].v.position;\n"
"    edgeVerts[1] = ProjectionMatrix * inpt[1].v.position;\n"
"    edgeVerts[2] = ProjectionMatrix * inpt[2].v.position;\n"
"\n"
"    edgeVerts[0].xy /= edgeVerts[0].w;\n"
"    edgeVerts[1].xy /= edgeVerts[1].w;\n"
"    edgeVerts[2].xy /= edgeVerts[2].w;\n"
"\n"
"    emit(0, position[0], normal[0], patchCoord[0], edgeVerts);\n"
"    emit(1, position[1], normal[1], patchCoord[1], edgeVerts);\n"
"    emit(2, position[2], normal[2], patchCoord[2], edgeVerts);\n"
"#else\n"
"    emit(0, position[0], normal[0], patchCoord[0]);\n"
"    emit(1, position[1], normal[1], patchCoord[1]);\n"
"    emit(2, position[2], normal[2], patchCoord[2]);\n"
"#endif\n"
"\n"
"    EndPrimitive();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//--------------------------------------------------------------\n"
"// Fragment Shader\n"
"//--------------------------------------------------------------\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"in block {\n"
"    OutputVertex v;\n"
"    noperspective in vec4 edgeDistance;\n"
"} inpt;\n"
"\n"
"out vec4 outColor;\n"
"\n"
"#define NUM_LIGHTS 2\n"
"\n"
"struct LightSource {\n"
"    vec4 position;\n"
"    vec4 ambient;\n"
"    vec4 diffuse;\n"
"    vec4 specular;\n"
"};\n"
"\n"
"layout(std140) uniform Lighting {\n"
"    LightSource lightSource[NUM_LIGHTS];\n"
"};\n"
"\n"
"uniform vec4 diffuseColor = vec4(1);\n"
"uniform vec4 ambientColor = vec4(1);\n"
"\n"
"vec4\n"
"lighting(vec4 diffuse, vec3 Peye, vec3 Neye)\n"
"{\n"
"    vec4 color = vec4(0);\n"
"\n"
"    for (int i = 0; i < NUM_LIGHTS; ++i) {\n"
"\n"
"        vec4 Plight = lightSource[i].position;\n"
"\n"
"        vec3 l = (Plight.w == 0.0)\n"
"                    ? normalize(Plight.xyz) : normalize(Plight.xyz - Peye);\n"
"\n"
"        vec3 n = normalize(Neye);\n"
"        vec3 h = normalize(l + vec3(0,0,1));    // directional viewer\n"
"\n"
"        float d = max(0.0, dot(n, l));\n"
"        float s = pow(max(0.0, dot(n, h)), 500.0f);\n"
"\n"
"        color += lightSource[i].ambient * ambientColor\n"
"            + d * lightSource[i].diffuse * diffuse\n"
"            + s * lightSource[i].specular;\n"
"    }\n"
"\n"
"    color.a = 1;\n"
"    return color;\n"
"}\n"
"\n"
"#ifdef USE_PTEX_DISPLACEMENT\n"
"vec3\n"
"perturbNormalFromDisplacement(vec3 position, vec3 normal, vec4 patchCoord)\n"
"{\n"
"    // by Morten S. Mikkelsen\n"
"    // http://jbit.net/~sparky/sfgrad_bump/mm_sfgrad_bump.pdf\n"
"    // slightly modified for ptex guttering\n"
"\n"
"    vec3 vSigmaS = dFdx(position);\n"
"    vec3 vSigmaT = dFdy(position);\n"
"    vec3 vN = normal;\n"
"    vec3 vR1 = cross(vSigmaT, vN);\n"
"    vec3 vR2 = cross(vN, vSigmaS);\n"
"    float fDet = dot(vSigmaS, vR1);\n"
"\n"
"    vec2 texDx = dFdx(patchCoord.xy);\n"
"    vec2 texDy = dFdy(patchCoord.xy);\n"
"    \n"
"    // limit forward differencing to the width of ptex gutter\n"
"    const float resolution = 128.0;\n"
"    float d = (0.5/resolution)/max(length(texDx), length(texDy));\n"
"    \n"
"    vec4 STll = patchCoord;\n"
"    vec4 STlr = patchCoord + d * vec4(texDx.x, texDx.y, 0, 0);\n"
"    vec4 STul = patchCoord + d * vec4(texDy.x, texDy.y, 0, 0);\n"
"    float Hll = PTexLookup(STll, textureImage_Data, textureImage_Packing, textureImage_Pages).x;\n"
"    float Hlr = PTexLookup(STlr, textureImage_Data, textureImage_Packing, textureImage_Pages).x;\n"
"    float Hul = PTexLookup(STul, textureImage_Data, textureImage_Packing, textureImage_Pages).x;\n"
"    float dBs = (Hlr - Hll)/d;\n"
"    float dBt = (Hul - Hll)/d;\n"
"    \n"
"    vec3 vSurfGrad = sign(fDet) * (dBs * vR1 + dBt * vR2);\n"
"    return normalize(abs(fDet) * vN - vSurfGrad);\n"
"}\n"
"#endif // USE_PTEX_NORMAL\n"
"\n"
"vec4\n"
"edgeColor(vec4 Cfill, vec4 edgeDistance)\n"
"{\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"    float d =\n"
"        min(inpt.edgeDistance[0], min(inpt.edgeDistance[1], inpt.edgeDistance[2]));\n"
"    vec4 Cedge = vec4(0.5, 0.5, 0.5, 1.0);\n"
"    float p = exp2(-2 * d * d);\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE)\n"
"    if (p < 0.25) discard;\n"
"#endif\n"
"\n"
"    Cfill.rgb = mix(Cfill.rgb, Cedge.rgb, p);\n"
"#endif\n"
"    return Cfill;\n"
"}\n"
"\n"
"void\n"
"main()\n"
"{\n"
"    vec3 N = (gl_FrontFacing ? inpt.v.normal : -inpt.v.normal);\n"
"#ifdef USE_PTEX_DISPLACEMENT\n"
"    N = perturbNormalFromDisplacement(inpt.v.position.xyz,\n"
"                                      N,\n"
"                                      inpt.v.patchCoord);\n"
"#endif\n"
"\n"
"    vec4 Cf = vec4(1.0);\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"    Cf = edgeColor(Cf, inpt.edgeDistance);\n"
"#endif\n"
"\n"
"#ifdef USE_PTEX_COLOR\n"
"    Cf = Cf * (vec4(1) - vec4(PTexLookup(inpt.v.patchCoord,\n"
"                                    textureImage_Data,\n"
"                                    textureImage_Packing,\n"
"                                         textureImage_Pages).x));\n"
"#endif\n"
"\n"
"    Cf = lighting(Cf, inpt.v.position.xyz, N);\n"
"\n"
"    outColor = Cf;\n"
"}\n"
"\n"
"#endif\n"
"\n"
