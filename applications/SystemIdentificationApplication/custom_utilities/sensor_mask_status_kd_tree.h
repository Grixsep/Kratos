//    |  /           |
//    ' /   __| _` | __|  _ \   __|
//    . \  |   (   | |   (   |\__ `
//   _|\_\_|  \__,_|\__|\___/ ____/
//                   Multi-Physics
//
//  License:         BSD License
//                   Kratos default license: DigitalTwinApplication/license.txt
//
//  Main authors:    Suneth Warnakulasuriya
//

#pragma once

// System includes
#include <tuple>
#include <vector>

// External includes
#include "nanoflann/include/nanoflann.hpp"

// Project includes
#include "includes/define.h"
#include "includes/ublas_interface.h"

// Application includes
#include "custom_utilities/sensor_mask_status.h"

namespace Kratos {
///@name Kratos Classes
///@{

class KRATOS_API(SYSTEM_IDENTIFICATION_APPLICATION) SensorMaskStatusKDTree {
private:
    ///@name Private classes
    ///@{

    class KratosMatrixKDTreeAdapter
    {
    public:
        ///@name Life cycle
        ///@{

        KratosMatrixKDTreeAdapter(const Matrix& rData): mrData(rData) {};

        ///@}

        ///@name API member functions

        // Must return the number of data poins
        inline IndexType kdtree_get_point_count() const
        {
            return mrData.size1();
        }

        // Must return the dim'th component of the idx'th point in the class:
        inline double kdtree_get_pt(const IndexType idx, int dim) const
        {
            return mrData(idx, dim);
        }

        // Optional bounding-box computation: return false to default to a standard bbox computation loop.
        //   Return true if the BBOX was already computed by the class and returned in "bb" so it can be avoided to redo it again.
        //   Look at bb.size() to find out the expected dimensionality (e.g. 2 or 3 for point clouds)
        template <class BBOX>
        bool kdtree_get_bbox(BBOX &bb) const
        {
            return false;
        }

        ///@}

    private:
        ///@name Private member variables
        ///@{

        const Matrix& mrData;

        ///@}
    };

public:
    ///@name Type definitions
    ///@{

    using IndexType = std::size_t;

    using ResultType = nanoflann::ResultItem<unsigned int, double>;

    using DistanceMetricType = nanoflann::metric_L1::traits<double, KratosMatrixKDTreeAdapter>::distance_t;

    using KDTreeIndexType = nanoflann::KDTreeSingleIndexAdaptor<DistanceMetricType, KratosMatrixKDTreeAdapter, -1>;

    KRATOS_CLASS_POINTER_DEFINITION(SensorMaskStatusKDTree);

    ///@}
    ///@name Life cycle
    ///@{

    SensorMaskStatusKDTree(
        SensorMaskStatus::Pointer pSensorMaskStatus,
        const IndexType LeafMaxSize);

    ///@}
    ///@name Public operations
    ///@{

    SensorMaskStatus::Pointer GetSensorMaskStatus() const;

    void RadiusSearch(
        const Vector& rQueryPoint,
        const double Radius,
        std::vector<ResultType> &IndicesDistances) const;

    /**
     * @brief Updates the kd tree for the masks generated by mpSensorMaskStatus.
     */
    void Update();

    ///@}

private:
    ///@}
    ///@name Private member variables
    ///@{

    const SensorMaskStatus::Pointer mpSensorMaskStatus;

    const IndexType mLeafMaxSize;

    std::unique_ptr<KratosMatrixKDTreeAdapter> mpKratosMatrixKDTreeAdapter;

    std::unique_ptr<KDTreeIndexType> mpKDTreeIndex;

    ///@}
};

} // namespace Kratos